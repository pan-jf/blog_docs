```json
{
  "date": "2021.05.04 12:00",
  "tags": ["sjjg","数据结构","PHP"]
}
```


## 定义
软件实体（类，模块，函数等等）应该可以扩展，但是不可修改。
<br />
## 如何理解


1. 对于扩展是开放的
1. 对于更改是封闭的


> 我们在做任何系统的时候，都不要指望系统一开始时需求确定，就再也不会变化。这是不现实也不科学的想法，既然需求是一定会变化的，那么如何在面对需求变化时，设计的软件相对容易修改，不至于说新需求一来就把整个程序推到重来。


<br />**怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？**
<br />

1. 开放-封闭原则要求我们在设计的时候，就时刻考虑尽量让这个类足够好，写好了就不要再修改，如果有新需求来，我们增加一些类，而尽量不动原来的代码。



2. 虽然原则要求如此，但是无论模块是多么的“封闭”，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测处最有可能发生的变化种类，然后构造抽象来隔离那些变化。



3. 猜测程序会发生的变化，猜对了是成功的，猜错了则会把程序设计的非常复杂。但我们可以在发生小变化的时候，就要及时想办法应对更大变化的可能，也就是说，等到变化发生时立即采取行动。



4. 在我们最初编写代码的时候，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。


> 比如第一章的加法程序，一开始是写一个加法程序，然后加一个减法功能，你发现增加功能需要修改原来这个类，这就违背了“开放-封闭原则”，于是你就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承，多态等来隔离具体加法，减法与client的耦合，需求依然可以满足，还能应对变化。这时候又要加乘除法功能，就不需要更改加法减法类了，而是增加乘法除法类即可。面对需求，对程序的改动是通过增加新代码进行的，而不是改变现有的代码。
> 当然，并不是什么时候应对变化都是容易的，我们希望的是在开发工作展开不就就知道可能发生的变化，查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
> 

## 总结

<br />**开放-封闭原则是面向对象设计的核心所在。**遵循这个原则可以带来对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

